/*
 * Solves any input Sudoku.
 * First attempts to solve trivially, then recursively solves the rest.
 *
 * Note: test cases are not generated by the program.
 * User can either enter their own stream of text, or load from a sample file.
 *
 * Authors: Jesse Deppisch, Joel C
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define TRUE 1
#define FALSE 0

/*
 * [Maybe] means that the spot could hold that value
 * If [value] is non-zero, then [maybe] is cleared
 */
typedef struct MarkUp {
	int maybe[9]; // Boolean - 1 if still a guess, 0 if not.
				  // e.g. maybe[8] == 1 means that there's a guess for 9
	int value; // Value of the tile, if there is one
} MarkUp;

typedef struct Sudoku {
	MarkUp board[9][9];
} Sudoku;

void initializeBoard(Sudoku *s);
void printBoard(Sudoku *s);

void setBoard(Sudoku *s, int choice);
void setCustomBoard(Sudoku *s);
void clearImpossible(Sudoku *s);

void setPossible(Sudoku *s);
Sudoku solve(Sudoku s);

void clearMaybe(Sudoku *s, int i, int j);

Sudoku search(Sudoku s);
int isSolved(Sudoku *s);
int checkBlock(Sudoku *s, int num, int i, int j);
int checkRow(Sudoku *s, int num, int i);
int checkCol(Sudoku *s, int num, int j);

int main() {
	/* Special calls */
	setbuf(stdout, NULL); // Necessary for Eclipse on Windows, because output is buffered

	/* Variable declaration and initialization */
	Sudoku s;
	initializeBoard(&s);

	char option = 'N';
	int choice = 0;

	/* Get user input */
	printf("Enter a string? (Y/N): ");
	scanf(" %c", &option);

	/* Set the board accordingly */
	if (option == 'Y' || option == 'y') {
		setCustomBoard(&s);
	} else {
		printf("Enter #(1-9): ");
		scanf(" %d", &choice);
		setBoard(&s, choice);
	}

	/* Print initial state */
	printf("\nInitial board:\n");
	printBoard(&s);

	/* Step 1 - Reduce possible values of [maybe] based on initial state */
	clearImpossible(&s);

	/* Step 2 - Solve as much as possible using simple techniques */
	int i=0;
	for ( i = 0; i < 100; i++) {
		setPossible(&s);
	}

	/* Step 3 - If not solved, recursive search to solve the rest */
	if (isSolved(&s) == FALSE) {
		s = solve(s);
	}

	/* Step 4 - Print the final board state */
	if (isSolved(&s)) {
		printf("\nSolved:\n");
		printBoard(&s);
	} else {
		printf("\nNot solved (unsolvable)\n");
	}

	return 0;
}

/*
 * Uses recursive searches to finish solving the Sudoku
 */
Sudoku solve(Sudoku s) {
	return search(s);
}

/*
 * Part of the solve() functionality - recursive depth search.
 * If unsolvable, returns initial state.
 */
Sudoku search(Sudoku s) {
	/* Return the final board if we've solved it */
	if (isSolved(&s) == TRUE) {
		return s;
	} else {
		/* Find the tile with least possible numbers left */
		int iPos = -1;
		int jPos = -1;
		int leastNums = 10;

		// Iterate through board
		int i=0, j=0;
		for ( i = 0; i < 9; i++) {
			for ( j = 0; j < 9; j++) {
				// Iterate through all numbers
				int nums = 0;
				int n = 0;
				for ( n = 0; n < 9; n++) {
					if (s.board[i][j].maybe[n] == 1) {
						nums++;
					}
				}
				// Determine if the tile has the least nums left
				if (nums < leastNums && nums > 0) {
					iPos = i;
					jPos = j;
					leastNums = nums;
				}
			}
		}

		/* Try all possibilities of the lowest-possibility tile */
		if (iPos != -1 && jPos != -1) {
			int n=0;
			for ( n = 0; n < 9; n++) {
				if (s.board[iPos][jPos].maybe[n] == 1) {
					/* Back up the board */
					Sudoku copy = s;

					/* Apply the move and search */
					copy.board[iPos][jPos].value = n + 1;
					clearMaybe(&copy, iPos, jPos);
					clearImpossible(&copy);

					/* If the move leads to success, return the solved state */
					Sudoku temp = search(copy);
					if (isSolved(&temp)) {
						return temp;
					}
					// Otherwise, return the state (at the end of the function, thus
					// attempting a different number on the tile

					// Note that the board that does not get solved "falls through" here
					// Because of this, the board, unchanged, is returned.
					// One might think this could end up returning an unsolved board, but keep in mind that
					// all possible moves are tried. Thus, the algorithm will keep trying until
					// it hits a solution, and returns that to the main function.
					// Note that an unsolvable sudoku will just return its initial state.

				}
			}
		}

		/* Return initial board if we can't make more moves */
		// Note that at this point, the function recursively checks if this is the correct solution.
		// If it is, we break out at this point - otherwise, other solutions are checked.
		return s;
	}
}

/*
 * Returns 1 if solved, 0 if not
 */
int isSolved(Sudoku *s) {
	/* Check rows and columns*/
	int x=0, n=1;
	for ( x = 0; x < 9; x++) {
		for ( n = 1; n < 10; n++) {
			if (checkRow(s, n, x) != TRUE || checkCol(s, n, x) != TRUE) {
				return FALSE;
			}
		}
	}

	/* Check blocks */
	int i=1, j=1; n=1;
	for ( i = 1; i < 8; i += 3) { // Will check { 1, 4, 7 }
		for ( j = 1; j < 8; j += 3) {
			for ( n = 1; n < 10; n++) {
				if (checkBlock(s, n, i, j) != TRUE) {
					return FALSE;
				}
			}
		}
	}

	return TRUE;
}
/*
 * Takes a string from the user and sets the board to that
 */
void setCustomBoard(Sudoku *s) {
	char input[82]; // todo - maybe 81? idk, includes space for '\0'
	int count = 0;

	printf("Input board: ");
	scanf(" %s", input);

	/* Put the info onto the board */
	int i=0, j=0;
	for ( i = 0; i < 9; i++) {
		for ( j = 0; j < 9; j++) {
			if (input[count] == '.' || input[count] == '*') {
				input[count] = '0';
			}
			s->board[i][j].value = input[count] - 48;
			if (input[count] != '0') {
				clearMaybe(s, i, j);
			}
			count++;
		}
	}
}

/*
 * Sets the tiles to a value if they only have 1 guess remaining
 * TODO - improve this description and other method descriptions
 */
void setPossible(Sudoku *s) {
	/* Iterate through the entire board */
	int i=0, j=0;
	for ( i = 0; i < 9; i++) {
		for ( j = 0; j < 9; j++) {

			/* Only check if there's no value */
			if (s->board[i][j].value == 0) {

				/* Check to see if only 1 number is left in guesses */
				int num = 0; int n=0;
				for ( n = 0; n < 9; n++) {
					if (s->board[i][j].maybe[n] == 1 && num == 0) {
						num = n + 1;
					} else if (s->board[i][j].maybe[n] == 1 && num != 0) {
						num = 0;
						break;
					}
				}

				/* If we have a number, set the tile value and clear [maybe] */
				if (num != 0) {
					s->board[i][j].value = num;
					clearMaybe(s, i, j);
				}
			}
		}
	}

	clearImpossible(s);
}

/*
 * Clears the impossible values from the board MarkUp [maybe]s.
 * E.g. If a 3x3 block has a 1, and another tile has
 * "1" as a [maybe], then the "1" is cleared from [maybe]
 */
void clearImpossible(Sudoku *s) {
	/* Iterate through the entire board */
	int i=0, j=0;
	for ( i = 0; i < 9; i++) {
		for ( j = 0; j < 9; j++) {

			/* Only bother clearing if the tile has no value */
			if (s->board[i][j].value == 0) {

				/* For nums 1-9, check block, row, and cols */
				int n=1;
				for ( n = 1; n < 10; n++) {

					/* Don't bother checking if no guess */
					if (s->board[i][j].maybe[n - 1] == 1) {

						/* Check as few as possible */
						if (checkRow(s, n, i) == TRUE) {
							s->board[i][j].maybe[n - 1] = FALSE;
						} else if (checkCol(s, n, j) == TRUE) {
							s->board[i][j].maybe[n - 1] = FALSE;
						} else if (checkBlock(s, n, i, j) == TRUE) {
							s->board[i][j].maybe[n - 1] = FALSE;
						}
					}
				}
			}
		}
	}
}

/*
 * Checks to see if the given number is already
 * a value in the block that (i,j) occupies.
 *
 * Returns 1 if the value exists in the block,
 * 0 if not
 */
int checkBlock(Sudoku *s, int num, int i, int j) {
	/* Initial declarations and initializations */
	int bRow = 0; // Center of block is used as reference
	int bCol = 0;

	/* Determine which block the (i,j) is in */
	int x=0, y=0;
	for ( x = 1; x < 8; x += 3) { // Will check { 1, 4, 7 }
		for ( y = 1; y < 8; y += 3) {
			if (abs(y - j) <= 1) {
				bCol = y;
			}
		}
		if (abs(x - i) <= 1) {
			bRow = x;
		}
	}

	/* Check if the value exists in the block */
	int k=-1, l=-1;
	for ( k = -1; k < 2; k++) {
		for ( l = -1; l < 2; l++) {
			if (s->board[bRow + k][bCol + l].value == num) {
				return TRUE;
			}
		}
	}

	return FALSE;
}

/*
 * Checks to see if the given number exists in the row.
 *
 * Returns 1 if the number exists in the row,
 * 0 if not.
 */
int checkRow(Sudoku *s, int num, int i) {
	int j=0;
	for ( j = 0; j < 9; j++) {
		if (s->board[i][j].value == num) {
			return TRUE;
		}
	}
	return FALSE;
}

/*
 * Checks to see if the given number exists in the column.
 *
 * Returns 1 if the number exists in the column,
 * 0 if not.
 */
int checkCol(Sudoku *s, int num, int j) {
	int i=0;
	for ( i = 0; i < 9; i++) {
		if (s->board[i][j].value == num) {
			return TRUE;
		}
	}
	return FALSE;
}

/*
 * Prints the given Sudoku board to the console. Minimalist.
 */
void printBoard(Sudoku *s) {
	/* Iterate through an (i,j) matrix */
	int i=0, j=0;
	for ( i = 0; i < 9; i++) {
		for ( j = 0; j < 9; j++) {

			/* Print the number. If not filled, print an asterisk */
			if (s->board[i][j].value != 0) {
				printf("%d ", s->board[i][j].value);
			} else {
				printf("* ");
			}

			/* Split the columns into 3s */
			if ((j + 1) % 3 == 0 && j != 8) {
				printf("| ");
			}
		}
		printf("\n");

		/* Split the rows into 3s */
		if ((i + 1) % 3 == 0 && i != 8) {
			printf("------+-------+------\n");
		}
	}
}

/*
 * Set the board to a known-solvable board
 * Choice should be a number 1-9
 */
void setBoard(Sudoku *s, int choice) {
	/* Build the file name */
	char fileName[11] = "known#.txt"; // # is 1-9
	fileName[5] = choice + 48;

	/* Variables for reading in the file */
	int i = 0;
	int j = 0;
	char rawVal = ' ';
	int val = 0;
	FILE *fPointer = fopen(fileName, "r");

	/* Read in the file */
	while (!feof(fPointer)) {
		// Grab the character and advance position
		rawVal = fgetc(fPointer);

		// Get the int value; e.g. "1" becomes 1
		val = rawVal - 48;

		// Update board
		if (rawVal == '*' || rawVal == '.') {
			j++;
		} else if (rawVal == '\n') {
			i++;
			j = 0;
		} else if (val > 0 && val < 10) {
			s->board[i][j].value = val;
			clearMaybe(s, i, j);

			j++;
		}
	}
	fclose(fPointer);
}

/*
 * Clears the [maybe] for a tile by setting all guesses to 0.
 */
void clearMaybe(Sudoku *s, int i, int j) {
	int n=0;
	for ( n = 0; n < 9; n++) {
		s->board[i][j].maybe[n] = 0;
	}
}

/*
 * Ensures that no weird memory issues happen,
 * because good practice is to initialize every variable.
 */
void initializeBoard(Sudoku *s) {
    int i=0, j=0, x=0;
	for ( i = 0; i < 9; i++) {
		for ( j = 0; j < 9; j++) {
			s->board[i][j].value = 0;
			for ( x = 0; x < 9; x++) {
				s->board[i][j].maybe[x] = 1;
			}
		}
	}
}
